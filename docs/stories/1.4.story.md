# Story 1.4: State Management Foundation

## Status
Ready

## Story
**As a** developer,
**I want** React Query configured for server state management,
**so that** I can handle API calls, caching, and loading states consistently.

## Acceptance Criteria
1. React Query setup with proper query client configuration
2. Basic query and mutation hooks structure established
3. Error and loading state handling patterns defined
4. Offline support and retry policies configured

## Tasks / Subtasks
- [ ] Install and configure React Query v5+ (AC: 1)
  - [ ] Install @tanstack/react-query and dependencies
  - [ ] Create QueryClient with proper configuration
  - [ ] Setup QueryClientProvider in app entry point
  - [ ] Configure offline support and retry policies
- [ ] Create query client configuration (AC: 1, 4)
  - [ ] Configure default query options (staleTime, cacheTime, retry)
  - [ ] Setup offline behavior and network status handling
  - [ ] Configure background refetching policies
  - [ ] Add query client persistence for offline support
- [ ] Establish query and mutation hooks structure (AC: 2)
  - [ ] Create base query hook patterns in app/src/hooks/
  - [ ] Create base mutation hook patterns for data modifications
  - [ ] Setup proper TypeScript interfaces for hooks
  - [ ] Create example hooks following established patterns
- [ ] Define error and loading state patterns (AC: 3)
  - [ ] Create standardized error handling patterns
  - [ ] Setup loading state management conventions
  - [ ] Create utility functions for common state patterns
  - [ ] Document patterns for consistent usage across app
- [ ] Write unit tests (Testing Standards Compliance)
  - [ ] Create tests for QueryClient configuration
  - [ ] Test query hook patterns and error handling
  - [ ] Test offline behavior and retry mechanisms
  - [ ] Test mutation hooks and optimistic updates

## Dev Notes

### Previous Story Insights
From Story 1.3: Navigation framework successfully established with TypeScript support. Service layer pattern and error handling implemented. All navigation components properly typed and tested.

### Data Models
State management will handle these core data types [Source: architecture/data-models.md]:
- **User Model**: Authentication state, profile data, notification preferences
- **Goal Model**: Active goals, roadmap data, goal status management  
- **WeeklyStage Model**: Current stage data, daily habits, success criteria
- **HabitLog Model**: Daily tracking data, completion status, user notes
- **Recalibration Model**: AI adjustment data, roadmap changes

### API Specifications
React Query will manage these API patterns [Source: architecture/api-specification.md]:
- **REST Endpoints**: `/rest/v1/goals`, `/rest/v1/weekly_stages`, `/rest/v1/habit_logs`
- **Edge Functions**: `/functions/v1/generate-roadmap`, `/functions/v1/recalibrate-roadmap`
- **Authentication**: JWT bearer tokens with Supabase Auth integration
- **Rate Limiting**: Generate roadmap (10/hour), recalibrate (5/day), REST (1000/hour)

### Component Specifications
**State Management Architecture from Frontend Architecture:**
- **Server State**: React Query 5.0+ for API caching and synchronization [Source: architecture/frontend-architecture.md#state-management-architecture]
- **Client State**: Zustand 4.4+ for UI state management [Source: architecture/tech-stack.md#tech-stack]
- **State Structure**: Global app state with auth, goals, stages, habitLogs, ui sections
- **State Patterns**: Optimistic updates, background refetching, offline support, persistent cache

### File Locations
Based on unified project structure, create files at these exact paths:
- **Query Client**: `app/src/services/api/queryClient.ts` [Source: architecture/unified-project-structure.md#unified-project-structure]
- **Query Hooks**: `app/src/hooks/useAuth.ts`, `app/src/hooks/useHabitTracking.ts`, `app/src/hooks/useOfflineSync.ts` [Source: architecture/unified-project-structure.md#unified-project-structure]
- **Store Files**: `app/src/stores/authStore.ts`, `app/src/stores/uiStore.ts` [Source: architecture/unified-project-structure.md#unified-project-structure]
- **Service Integration**: Update `app/src/services/api/supabase.ts` for React Query integration
- **Tests**: `app/src/hooks/__tests__/`, `app/src/services/__tests__/` [Source: architecture/testing-strategy.md#test-organization]

### Testing Requirements
**Testing Standards from Architecture:**
- **Test Framework**: Jest + React Native Testing Library for hooks and components [Source: architecture/tech-stack.md#tech-stack]
- **Test Standards**: 70% unit tests, 30% integration tests [Source: architecture/testing-strategy.md#testing-pyramid]
- **Test Organization**: Follow pattern `app/src/hooks/__tests__/` and `app/src/services/__tests__/` [Source: architecture/testing-strategy.md#test-organization]
- **Hook Testing**: Custom React hooks must have unit tests covering all state transitions, error cases, and loading states

### Technical Constraints
- **React Query Version**: 5.0+ required [Source: architecture/tech-stack.md#tech-stack]
- **TypeScript Version**: 5.3+ required [Source: architecture/tech-stack.md#tech-stack]
- **State Management**: React Query for server state, Zustand for client state [Source: architecture/tech-stack.md#tech-stack]
- **Offline Support**: React Query cache with persistence for offline-first functionality [Source: architecture/tech-stack.md#tech-stack]

### Critical Fullstack Rules
- **API Calls**: Never make direct HTTP calls - use the service layer [Source: architecture/coding-standards.md#critical-fullstack-rules]
- **State Updates**: Never mutate state directly - use proper state management patterns [Source: architecture/coding-standards.md#critical-fullstack-rules]
- **Async Operations**: Always handle loading and error states in UI [Source: architecture/coding-standards.md#critical-fullstack-rules]
- **Type Sharing**: Always define types in shared/types and import from there [Source: architecture/coding-standards.md#critical-fullstack-rules]
- **Environment Variables**: Access only through config objects, never process.env directly [Source: architecture/coding-standards.md#critical-fullstack-rules]

### Service Layer Integration
React Query configuration must integrate with existing Supabase service [Source: architecture/frontend-architecture.md#frontend-services-layer]:
- **Supabase Client**: Use existing `app/src/services/api/supabase.ts` configuration
- **Auth Integration**: Automatic token management with AsyncStorage persistence
- **Realtime Support**: React Query subscriptions for realtime data updates
- **Error Handling**: Consistent error format across all API calls

### Query Configuration Requirements
- **Default Options**: staleTime: 5 minutes, cacheTime: 30 minutes, retry: 3 attempts
- **Background Refetch**: On window focus and network reconnect
- **Offline Behavior**: Pause queries when offline, resume on reconnect
- **Optimistic Updates**: For habit logging and goal updates
- **Cache Persistence**: Use React Query persist plugin for offline support

### Project Structure Notes
No conflicts detected between epic requirements and defined project structure. All state management locations align with unified project structure specification. React Query and Zustand integration follows established frontend architecture patterns.

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|---------|
| 2025-01-09 | 1.0 | Initial story creation | Bob (Scrum Master) |

## Dev Agent Record

### Agent Model Used
[To be populated by Dev Agent]

### Debug Log References
[To be populated by Dev Agent]

### Completion Notes List
[To be populated by Dev Agent]

### File List
[To be populated by Dev Agent]

## QA Results
[To be populated by QA Agent]